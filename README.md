# Stage 2 – Professionalization of the Java Project

## Introduction
This project corresponds to Stage 2 of the DREAM-TEAM-ULPGC initiative. Its goal is to professionalize the development of a distributed Java-based system using a set of small services (control-service, ingestion-service, indexer-service and search-service). Each service is responsible for a single part of the data pipeline. The control-service, in particular, is implemented with Javalin as the HTTP server, so the orchestration layer is lightweight and focused on exposing REST endpoints.

## Repository Structure
- /control-service  
  Service that exposes HTTP endpoints using Javalin. Its role is to coordinate or trigger actions on the rest of the services. Here is where the orchestration logic lives: start ingestion, start indexing, check status. It is a Java application with Javalin as the web framework.
- /ingestion-service  
  Service dedicated to obtaining data from the configured source(s), validating it and preparing it to be indexed. It exposes its own REST endpoints (Java) so that the control-service or other tools can tell it to start ingestion.
- /indexer-service  
  Service that receives or reads the data already ingested and transforms it into a structure suitable for search. It also exposes REST endpoints to be invoked after ingestion is completed.
- /search-service  
  Service that exposes search endpoints (HTTP/REST) so that a client can query the data that was indexed by the indexer-service.
- pom.xml  
  Maven configuration at the root of the repository to build the modules.
- README.md  
  This document.

All four folders you listed correspond to working services in the same project, so the idea is that they can be built separately but belong to the same overall system.

## Technologies and Tools (only what is visible from your description)
- Language: Java
- HTTP framework in control-service: Javalin
- Build tool: Maven (root pom.xml and per-service poms)
- API style: REST (HTTP endpoints in control-service via Javalin, and REST endpoints in the other services)
- Version control: Git / GitHub

## Architecture Overview
The architecture is service-oriented: each folder is an independent Java service.

1. control-service (Javalin)
   - Starts a Javalin server.
   - Defines routes/endpoints (for example, POST endpoints) that act as orchestration commands.
   - From here you can call ingestion-service and indexer-service in the right order.
   - It is the entry point for operators or for other systems that want to trigger the pipeline.

2. ingestion-service
   - Responsible for fetching or receiving the source data.
   - Validates and normalizes the data.
   - Stores or exposes the data so that indexer-service can consume it.
   - Can be called by control-service once an ingestion job is needed.

3. indexer-service
   - Reads data that has already been ingested.
   - Builds an index or an internal searchable structure.
   - Exposes an endpoint to be triggered (for example, after ingestion finishes).
   - Acts as the bridge between “available data” and “searchable data”.

4. search-service
   - Exposes HTTP endpoints to let a client search the indexed data.
   - Uses the index generated by indexer-service.
   - Returns results, usually filtered or paginated.

The typical flow is: control-service (Javalin) -> ingestion-service -> indexer-service -> search-service.

## Communication Flow
1. A client or operator calls an HTTP endpoint on control-service (Javalin).
2. control-service’s Javalin handler executes logic that calls ingestion-service (usually via HTTP) to start ingestion.
3. ingestion-service completes ingestion and leaves the data ready.
4. control-service (or ingestion-service, depending on how you chained it) calls indexer-service to build the index.
5. Once indexing is done, search-service can answer queries from clients.
6. All services can log what they are doing so that control-service (or the developer) can follow the process.

## Installation and Execution
1. Clone the repository:
   git clone https://github.com/DREAM-TEAM-ULPGC/stage_2.git
2. Move to the project root:
   cd stage_2
3. Build the whole project with Maven:
   mvn clean install
4. Run control-service (Javalin):
   cd control-service
   mvn exec:java
   or, if the service has a main class configured for Maven, the usual:
   mvn clean package
   java -jar target/control-service-*.jar
   (use the exact jar name produced by your build)
5. Run ingestion-service in another terminal:
   cd ingestion-service
   mvn clean package
   java -jar target/ingestion-service-*.jar
6. Run indexer-service:
   cd indexer-service
   mvn clean package
   java -jar target/indexer-service-*.jar
7. Run search-service:
   cd search-service
   mvn clean package
   java -jar target/search-service-*.jar
8. Run tests (from the root):
   mvn test

Notes:
- control-service will start a Javalin server on the port configured in its code (for example 7000 or 8080, depending on how it is written).
- The other services should also expose their endpoints on their configured ports.
- To run all at once you need one terminal per service.

## Main Features
- Javalin-based control layer: very lightweight HTTP layer for orchestration.
- Clear separation of concerns: control-service does orchestration; ingestion-service does data input; indexer-service does data preparation for search; search-service does querying.
- REST endpoints in all services so they can call each other over HTTP.
- Maven build per service to keep dependencies isolated.

## Development Guidelines
- Keep the control-service routes in Javalin grouped and named by operation (for example, /ingest, /index, /status).
- When you add a new endpoint in ingestion-service or indexer-service, update the control-service to call it if it is part of the orchestration.
- Use the same Java version in all services to avoid build issues.
- Run mvn clean install in the root before pushing to make sure all services compile.
- Keep each service runnable on its own so you can debug it in isolation.

## Team Information
- Team: DREAM-TEAM-ULPGC
- University: Universidad de Las Palmas de Gran Canaria
- Stage: Stage 2 – Professionalization of Java Code and Distributed Microservices System
